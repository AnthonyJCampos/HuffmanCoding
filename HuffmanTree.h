/** @file HuffmanTree.h
 @author Anthony Campos
 @date 01/26/2022
 This header class file implements a HuffmanTree of HuffNodes
	that hold a char and the int count of the specific char */

	//---------------------------------------------------------------------------
	// HuffmanTree class:  Tree data structure
	//   included features:
	//   -- allows for construction by char & int, HuffmanTree, 
	//			and HuffmanTree & HuffmanTree
	//   -- allows for comparison of 2 HuffmanTree, by their roots
	//   -- allows for assignment and copy of 2 HuffmanTrees
	//   -- provides Huffuman encoder and decoder
	//
	// Assumptions:
	//   --  Non-leaves should store the sum of the weights of the descendant leaves.
	//---------------------------------------------------------------------------

#pragma once

// Included libraries
#include <string>
#include <vector>

// Global Variable for length/size of codebook_ array
const int NUM_LETTERS = 26;


class HuffmanTree {

public:

	/** Constructors & Destructor */

	/** Defualt Constructor
	@pre None
	@post Empty HuffmanTree Object created*/
	HuffmanTree();

	/** Constructor
	@pre letter is a valid char, count > 1 & count < 2147483647
	@post Empty HuffmanTree Object created
	@param char [letter], int [count]*/
	HuffmanTree(const char& letter, const int& count);

	/** Constructor
	@pre neither source HuffmanTrees are empty
	@post Empty HuffmanTree Object created and source trees memory captured. 
	calls combineTrees*/
	HuffmanTree(HuffmanTree& leftSource, HuffmanTree& rightSource);


	/** Copy Constructor
	@pre None
	@post source HuffmanTree deep copied and New HuffmanTree allocated.
	Calls the clearTree dellocate memory and  copyTree to copy HuffmanTree
	@parm HuffmanTree [sourceTree]*/
	HuffmanTree(const HuffmanTree& sourceTree);



	/** Destructor
	@pre none
	@post destroy HuffmanTree and release memory */
	~HuffmanTree();

	/** Public Methods */

	/* Overloaded Assigment Operator
	@pre None
	@post left hand HuffmanTree object equals the right hand HuffmanTree object
	Checks for self assignment and calls clearTree to release memory, calls copyTree to deep copy
	@param HuffmanTree [rhsTree] object to equal
	@return HuffmanTree oject is now equal to right hand HuffmanTree object */
	HuffmanTree& operator=(const HuffmanTree& rhsTree);

	/** Overloaded operator<
	@pre None
	@post Node
	@param HuffmanTree [rhsTree]
	@return if rhsTree root_ count value is greater then left hand side tree, otherwise false. 
	If TIE tree storing the earliest character is less then, */
	bool operator<(const HuffmanTree& rhsTree) const;

	/** Accessor Methods */

	/* encode updates parm codebook to contain char codes generate by the encoder
	@pre Huffman tree has already been completed/filled 
	@post codebook updated to contain 26 codes for 26 chars
	calls encoder to decode Hufftree to generate codes
	@param std::string array [codebook] passed by reference*/
	void encode(std::string (&codebook)[NUM_LETTERS]) const;

	/* decode returns text per the provided code
	@pre code provided must be valid code for the current HuffmanTree
	@post a string that represents text per the provided code
	calls decoder to decode Hufftree to generate text
	@param std::string [code] 
	@return a string that represents the coded message*/
	std::string decode(const std::string code) const;



private:

	/** Private Attributes */

	struct HuffNode {

		/** Constructor */
		/** Defualt Constructor
		@pre None
		@post HuffNode Object created*/
		HuffNode();

		/** Attributes */

		// left and right children pointers
		HuffNode* leftChild_;
		HuffNode* rightChild_;

		char item_; // default value, '\0'
		int count_; // default value,  0

	}; // end of HuffNode

	/** Attributes */

	// root of tree structure
	HuffNode* root_;

	/** Private Methods */

	/**  combineTrees, combines two trees together by their root
	@pre neither root is nullptr
	@post a pointer to the new HuffmanTree is returned, and 
	the memory is captured from the inputted trees
	@parm HuffNode[lhsRoot], HuffNode[rhsRoot]
	@return pointer to root of new tree*/
	HuffNode* combineTrees(HuffNode*& lhsRoot, HuffNode*& rhsRoot);

	/** copyTree copies the the source tree
	@pre none
	@post provided tree copied and pointer to the copy returned
	@parm HuffNode* [sourceRoot] tree's root to copy
	@return a copy of the provided tree*/
	HuffNode* copyTree(const HuffNode* sourceRoot) const;

	/** clearTree destroys the tree object
	@pre none
	@post all memory for the SearchTree object is deallocated
	@parm HuffNode* [subTreePtr] pointer to the root of the tree*/
	void clearTree(HuffNode*& subTreePtr);

	/* encoder helps the encode method update codebook parm to contain char codes 
	generated by traversing the tree
	@pre Huffman tree has already been completed/filled/Not Empty
	@post codebook updated to contain 26 codes for 26 chars
	@param HuffNode [subTreePtrstd],  std::string array [codebook] & std::string [code] passed by reference*/
	void encoder(const HuffNode* subTreePtr, std::string(&codebook)[NUM_LETTERS], std::string& code) const;


	/* decoder helps the decode method decipher the provided code into text
	generated by traversing the tree
	@pre Huffman tree has already been completed/filled/Not Empty
	@post text variable updated to reflected deciphered code
	@param HuffNode [subTreePtrstd], std::string [code] & std::string [text] passed by reference, unsigned int [index]*/
	void decoder(const HuffNode* subTreePtr, const std::string& code, unsigned int index, std::string& text) const;

}; // end of HuffmanTree
